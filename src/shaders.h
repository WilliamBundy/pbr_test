const char* frag3d = "" "#version 450\n"
"// Normal from model\n"
"in vec4 fNormal;\n"
"// This is always white\n"
"in vec3 fRGB;\n"
"in vec3 fPos;\n"
"in vec3 fEye;\n"
"// I actually think these should be STs in OpenGL parlance?\n"
"// UV = pixel space\n"
"// ST = normalized image space\n"
"// Not that important\n"
"in vec2 fUV;\n"
"// Color output\n"
"out vec4 gColor;\n"
"// We need this for light and normal transforms\n"
"uniform mat4 uView;\n"
"// Light struct and scene buffer\n"
"// I'm using vec4's to be explicit; everything's aligned to 16 bytes anyway\n"
"struct Light\n"
"{\n"
"	vec4 pos;\n"
"	vec4 color;\n"
"};\n"
"layout(std430, location=1) buffer SceneBuffer\n"
"{\n"
"	Light lights[16];\n"
"	int lightCount;\n"
"} scene;\n"
"// All of our textures. I could have made a texture array, but this was simpler\n"
"uniform sampler2D uDiffuse;\n"
"uniform sampler2D uNormal;\n"
"uniform sampler2D uPbr;\n"
"uniform sampler2D uEmissive;\n"
"// f0 is base specular\n"
"// Product could be NdV or HdV depending on technique\n"
"// We use the latter with Cook-Torrance\n"
"vec3 fresnelFactor(vec3 f0, float product)\n"
"{\n"
"	return mix(f0, vec3(1.0), pow(1.0 - product, 5.0));\n"
"}\n"
"// Code here borrowed from UE4\n"
"// I went with this distribution function... it sounds cool?\n"
"float D_GGX(float roughness, float NdH)\n"
"{\n"
"	float m = roughness * roughness;\n"
"	float m2 = m * m;\n"
"	float d = (NdH * m2 - NdH) * NdH + 1.0;\n"
"	return m2 / (3.1415926 * d * d);\n"
"}\n"
"// G is the geometry shading term\n"
"float G_schlick(float roughness, float NdV, float NdL)\n"
"{\n"
"	float k = roughness * roughness * 0.5;\n"
"	float V = NdV * (1.0 - k) + k;\n"
"	float L = NdL * (1.0 - k) + k;\n"
"	return 0.25 / (V * L);\n"
"}\n"
"float G_schlickGGX(float roughness, float NdV)\n"
"{\n"
"	float r = roughness + 1;\n"
"	float k = (r * r) / 8.0;\n"
"	return NdV / (NdV * (1.0 - k) + k);\n"
"}\n"
"float G_smith(float roughness, float NdV, float NdL)\n"
"{\n"
"	float ggx2 = G_schlickGGX(roughness, NdV);\n"
"	float ggx1 = G_schlickGGX(roughness, NdL);\n"
"	return ggx1 * ggx2;\n"
"}\n"
"// \n"
"vec3 specularCookTorrance(float NdL, float NdV, float NdH, \n"
"		vec3 F, float rough)\n"
"{\n"
"	float D = D_GGX(rough, NdH);\n"
"	float G = G_smith(rough, NdV, NdL);\n"
"	return F * G * D / max(4 * NdL * NdV, 0.001);\n"
"}\n"
"// The big idea with PBR is to model materials based on our physical\n"
"// understanding of light. It turns out that we actually don't need\n"
"// that much data to do this:\n"
"// 		- albedo is the diffuse light/base color\n"
"// 		- metallic models how much metal is in a material,\n"
"// 		which directly affects how it reflects light\n"
"// 		- roughness models the microscopic bumps on a surface;\n"
"// 		the rougher it is, the more diffuse the reflected light\n"
"// 		- normals aren't technically PBR, but they help generate\n"
"// 		bigger details on a surface that reflect light differently.\n"
"//\n"
"// From here, there's a few things I could do to make it better:\n"
"// 		- I never actually tested it with some impostored spheres, \n"
"// 		just the model. If Nsight actually worked, doing this would\n"
"// 		be a great way to debug it.\n"
"// 		- Image Based Lighting: as it is, the scene is very dark, \n"
"// 		because (at least, I think this is the case), when no light\n"
"// 		is entering a fragment from a point light, the fragment \n"
"// 		'reflects' the darkness. IBL more-or-less substitutes reflecting\n"
"// 		that with reflecting a cubemap around it.\n"
"// 		- All of the physical lighting ideas could be implemented\n"
"// 		in my raytracer. A lot of these come from raytracing originally;\n"
"// 		it's essentially pushing more data through the algorithm.\n"
"// 		- You can kind of see lights through the models?\n"
"// 		- Shadow mapping (with attention given to self-shadowing)\n"
"void main()\n"
"{\n"
"	vec4 color = texture(uDiffuse, fUV) * vec4(fRGB, 1);\n"
"	vec4 normal = texture(uNormal, fUV);\n"
"	vec4 pbr = texture(uPbr, fUV);\n"
"	vec4 emissive = texture(uEmissive, fUV);\n"
"	\n"
"	// Apply ambient occlusion to albedo map\n"
"	color *= pbr.z;\n"
"	vec3 vertexNormal = fNormal.xyz;\n"
"	//create TBN matrix\n"
"	vec3 posDx = dFdx(fPos);\n"
"	vec3 posDy = dFdy(fPos);\n"
"	vec2 texDx = dFdx(fUV);\n"
"	vec2 texDy = dFdy(fUV);\n"
"	vec3 tangent = normalize(texDy.y * posDx - texDx.y * posDy);\n"
"	vec3 binormal = normalize(texDy.x * posDx - texDx.x * posDy);\n"
"	//rebuild tangent from existing normal\n"
"	vec3 xAxis = cross(vertexNormal, tangent);\n"
"	tangent = normalize(cross(xAxis, vertexNormal));\n"
"	//now bi-tangent\n"
"	xAxis = cross(binormal, vertexNormal);\n"
"	binormal = normalize(cross(vertexNormal, xAxis));\n"
"	mat3 tbn = mat3(tangent, binormal, vertexNormal);\n"
"	//transform normal map into real space\n"
"	vec3 N = normalize(tbn * (normal.xyz * 2.0 - 1.0));\n"
"	// grab some PBR terms\n"
"	float roughness = pbr.y;\n"
"	float metallic = pbr.x;\n"
"	// 0.04 here is a base specular for non-metallic materials\n"
"	// Also called F0 for Frenel equation\n"
"	// F0 = lerp(0.4, albedo, metallic)\n"
"	vec3 specular = mix(vec3(0.04), color.xyz, metallic);\n"
"	\n"
"	// output color in linear space\n"
"	vec3 lightSum = vec3(0);\n"
"	\n"
"	for(int i = 0; i < scene.lightCount; ++i) {\n"
"		// Light position in view space\n"
"		vec3 localLight = (uView * vec4(scene.lights[i].pos.xyz, 1)).xyz;\n"
"		\n"
"		// The constant here is an artistic choice\n"
"		// Values >1 are effectively a multiplier on brightness\n"
"		float attenuation = 4.0 / dot(localLight - fPos, localLight - fPos);\n"
"		vec3 lightDirection = normalize(localLight - fPos);\n"
"		vec3 V = fEye;\n"
"		vec3 L = lightDirection;\n"
"		// If you think of fViewPos as the position in view space\n"
"		// it's like a line from the camera to the fragment\n"
"		// So the opposite of it is a line from the fragment to the camera\n"
"		//vec3 viewDirection = normalize(-fEyePos);\n"
"		\n"
"		// Not sure how to motivate this term?\n"
"		// I think it ends up being the reflection direction\n"
"		vec3 H = normalize(lightDirection + fEye);\n"
"		// Doing all of these dot products together rather\n"
"		// than spreading them out over the various equations\n"
"		// We put bounds on them to help keep the numbers sane\n"
"		float NdL = max(0.0,   dot(N, L));\n"
"		float NdV = max(0.001, dot(N, V));\n"
"		float NdH = max(0.001, dot(N, H));\n"
"		float HdV = max(0.001, dot(H, V));\n"
"		float LdV = max(0.001, dot(L, V));\n"
"		// This is the 'magic'\n"
"		// The BRDF lets us understand the light entering\n"
"		// and exiting the fragment, so we can choose whether \n"
"		// to make it bright or soft\n"
"		vec3 specFresnel = fresnelFactor(specular, HdV);\n"
"		//specular reflectance\n"
"		vec3 specRef = specularCookTorrance(\n"
"				NdL, NdV, NdH,\n"
"				specFresnel,\n"
"				roughness);\n"
"		specRef *= vec3(NdL);\n"
"		// constant here is the phong/lambertian diffuse term, ie 1.0 / PI\n"
"		vec3 diffuseRef = (vec3(1.0) - specFresnel) * 0.3183098 * NdL;\n"
"		// Just... go ahead and assemble light from what we've got.\n"
"		vec3 reflectedLight = vec3(0);\n"
"		vec3 diffuseLight = vec3(0);\n"
"		vec3 radiance = scene.lights[i].color.rgb * attenuation;\n"
"		reflectedLight += specRef * radiance;\n"
"		diffuseLight += diffuseRef * radiance;\n"
"		diffuseLight += emissive.rgb;\n"
"		reflectedLight += emissive.rgb;\n"
"		//...and here's where we'd do IBL lighting with a cubemap\n"
"		// Apparently the surface we have here is almost completely metallic, \n"
"		// which means that the diffuse light terms are almost completely \n"
"		// cancelled out (on the spaceship model)\n"
"		vec3 result = diffuseLight * mix(color.xyz, vec3(0), metallic) + reflectedLight;\n"
"		\n"
"		// This is technically squaring the NdL term\n"
"		// ...but I think it looks better, so I left it in.\n"
"		lightSum += result;\n"
"	}\n"
"	// Gamma correction\n"
"	lightSum = lightSum / (lightSum + vec3(1.0));\n"
"	lightSum = pow(lightSum, vec3(1.0/2.2));\n"
"	gColor = vec4(lightSum, 1);\n"
"}\n"
;
const char* fragSimple = "" "#version 330\n"
"in vec2 fPos;\n"
"in vec4 fColor;\n"
"out vec4 gColor;\n"
"void main()\n"
"{\n"
"	vec4 color = fColor;\n"
"	float dist2 = dot(fPos, fPos) - 0.25; //0.5 ^ 2\n"
"	if(dist2 > 0) discard;\n"
"	gColor = color;\n"
"}\n"
;
const char* vert3d = "" "#version 330\n"
"layout(location=0) in vec4 vPos;\n"
"layout(location=1) in vec4 vNormal;\n"
"layout(location=2) in vec2 vUV;\n"
"out vec4 fNormal;\n"
"out vec3 fRGB;\n"
"out vec3 fPos;\n"
"out vec3 fEye;\n"
"out vec2 fUV;\n"
"uniform vec3 uOffset;\n"
"uniform mat4 uProjection;\n"
"uniform mat4 uView;\n"
"uniform vec2 uTextureSize;\n"
"void main()\n"
"{\n"
"	vec4 localPos = uView * vec4(uOffset + vPos.xyz, 1);\n"
"	gl_Position = uProjection * localPos; \n"
"	fPos = localPos.xyz;\n"
"	fEye = normalize(-fPos);\n"
"	fRGB = vec3(1.0, 1.0, 1.0);\n"
"	fUV = vUV;\n"
"	fNormal = transpose(inverse(uView)) * vNormal;\n"
"}\n"
;
const char* vertSimple = "" "#version 330\n"
"layout(location=0) in vec4 vPos;\n"
"layout(location=1) in vec4 vColor;\n"
"layout(location=2) in vec4 vPbr;\n"
"// normalized position within quad\n"
"// this gets interpolated over the fragment shader\n"
"out vec2 fPos;\n"
"out vec4 fColor;\n"
"uniform mat4 uView;\n"
"uniform mat4 uProjection;\n"
"float[4] corners = float[4](-0.5, -0.5, 0.5, 0.5);\n"
"void main()\n"
"{\n"
"	float size = 2;\n"
"	int vx = gl_VertexID & 2;\n"
"	int vy = ((gl_VertexID & 1) << 1) ^ 3;\n"
"	vec2 vert = size * vec2(corners[vx], corners[vy]);\n"
"	vec3 cameraLeft = vec3(uView[0][0], uView[1][0], uView[2][0]);\n"
"	vec3 cameraUp = vec3(uView[0][1], uView[1][1], uView[2][1]);\n"
"	vec4 lpos = vec4(vPos.xyz + cameraLeft * vert.x + cameraUp * vert.y, 1);\n"
"	gl_Position = uProjection * uView * lpos;\n"
"	fColor = vColor;\n"
"	fPos = vert;\n"
"}\n"
;
